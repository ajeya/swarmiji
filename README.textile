h1. swarmiji

swarmiji is a framework that helps in writing distributed programs using the clojure programming language. I wrote it because our startup (<a href="http://runa.com">Runa</a>) needed computations to span not just clojure agents within single JVMs but across machines. This especially became the case as our load grew. 

swarmiji uses the fantastic <a href="http://rabbitmq.com">RabbitMQ</a> as its central nervous system to communicate between service requesters and (possibly multiple) workers. It provides simple constructs to create these distributed services and makes it very easy to use them in your code. It has support for additional things like - automatic time-outs (if a worker fails), and a simple metrics collection system (to see how long services are taking, and where time is being spent). It also packages a very simple web-framework that allows clojure functions (that might use swarmiji) to be exposed as web-services.

Contributions are welcome, as are recommendations for how to improve things.

h2. example

The easiest way to understand how to use swarmiji is to see an example. Consider the code below which is written in the traditional way:

<pre><code>
(defn monthly-spend [month]
    (total-spend-for-days (days-of-month month))

(defn total-quarterly-spend []
    (let [first (monthly-spend (first-month-of-quarter))
          second (monthly-spend (second-month-of-quarter))
          third (monthly-spend (third-month-of-quarter))]
      (+ first second third)))
</pre></code>

Some imagination is needed - lets assume that total-spend-for-days is a long running process that calculates important stuff. Total-quarterly-spend, then takes three times as long. However, since each month's calculation is basically independent of each other, we could run this in parallel. If you'd this parallelism to take advantage of a horizontally scalable cluster, these computations need to run on different machines. 

The following code shows how the above can be converted into using swarmiji. This version runs in parallel on distributed machines:

<pre><code>
(defsevak monthly-spend [month]
    (total-spend-for-days (days-of-month month))

(defn total-quarterly-spend []
    (let [first (monthly-spend (first-month-of-quarter))
          second (monthly-spend (second-month-of-quarter))
          third (monthly-spend (third-month-of-quarter))]
      (from-swarm 1000 [first second third]
        (+ (first :value) (second :value) (third :value))))
</pre></code>

What's happening here is that instead of using the good old defn to define monthly-spend, we use defsevak. Then, when you call the function, what is returned is not the value but a proxy object which represents the computation on another CPU. You can call as many such sevaks as you want, and when you're ready to combine the results to produce the final result you use the from-swarm macro to synchronize. 


h2. sevaks and defsevak

In Hindi, the word sevak means servant or worker. In swarmiji, you define such workers using the defsevak macro. Sevaks can transparently run on another machines (or multiple machines) by simply changing a configuration parameter (:distributed-mode) to true. 

defsevak works exactly like defn.

h2. from-swarm

Since each sevak runs asynchronously, there needs to be a construct that ensures all dispatched sevaks have completed. from-swarm is a macro that does just that - it accepts a timeout and a list of sevaks to wait on. Once the sevaks have all compelted, the code block is executed. If, instead, the sevaks don't all complete within the specified timeout (specified in milliseconds), an exception is thrown.
 
It can get cumbersome to always pass a timeout wherever from-swarm is called, so its idiomatic to create a macro which wraps from-swarm and uses an appropriate global timeout value.

h2. What does calling a sevak return?

Calling a sevak looks exactly like calling a regular function. However while a regular function returns the result of the function body, a sevak returns a proxy object that is the representation of the computation happening somewhere on the cloud. This object then must be queried to get the result out. This object also has lots of other information about the computation which can also be queried for. Querying this object is easy - since this object is really a function, you just call it with a query symbol as its argument. The most commonly used one is :value and it looks like -

(some-sevak-object :value) This code returns the final computed result of the sevak.

All the supported arguments supported are:  

|argument| what does it return? |
|:value| the result of the sevak computation|
|:distributed?| is this sevak running locally or on a remote computer?|
|:complete? | returns true if the sevak has completed its job |
|:status | returns :success if the sevak run was successful, else :error if there was a problem |
|:sevak-time | returns the CPU time spent executing the sevak body |
|:messaging-time | returns the time taken in the messaging overhead of sending and receiving the sevak over RabbitMQ |
|:total-time | returns the total of the :sevak-time and :messaging-time |
|:exception | returns the name of the exception thrown by the sevak on the remote computer |
|:stacktrace | returns the stacktrace of the exception thrown by the sevak on the remote computer|


config


h2. swarmiji

Swarm. Swamiji. Ahahaha.
 
Copyright 2009 Amit Rathore







from-swarm

Sevaks can run on any machine that is available to do the work. The object returned by a call to a sevak represents this computation. Since the time taken to execute this computation is non-deterministic (depends on how much work there is, the load on the cluster, etc.) these object are essentially asynchronous in nature. Thus, when we're ready to use results from one or more sevaks, we must use a synchronization construct. This is what the from-swarm macro does - it accepts a time-out along with a list of sevaks to synchronize on - the process will basically wait at this point until all the sevaks complete.


:distributed? the response to this messages is whether or not swarmiji is running in distributed-mode. swarmiji can be made to run in non-distributed-mode which is often useful for unit-testing, etc.

:complete? 

Round robin













